# Estrategia para Manejo de Archivos Adjuntos en Sistema de Incidencias

## üéØ Problema Identificado

Los archivos adjuntos a incidencias **NO contienen informaci√≥n que los relacione directamente con la incidencia**. El √∫nico enlace es el **nombre del archivo** que incluye el ID de incidencia como prefijo.

Ejemplo:
```
INC-2024-001_error_log.txt
INC-2024-001_screenshot.png
INC-2024-002_network_trace.pcap
```

## üìä An√°lisis de Opciones

### ‚ùå Opci√≥n NO Recomendada: Sincronizar archivos directamente con Knowledge Base

**Problemas**:
1. Los archivos no tienen contexto de la incidencia
2. La b√∫squeda sem√°ntica no encontrar√≠a relaci√≥n
3. Desperdicio de espacio en el √≠ndice vectorial
4. Costos innecesarios de embeddings

### ‚úÖ Opci√≥n Recomendada: Arquitectura de Dos Niveles (Tu Propuesta)

**Nivel 1: Knowledge Base** ‚Üí Solo metadatos de incidencias
**Nivel 2: S3** ‚Üí Archivos adjuntos organizados por ID

Esta es la **mejor soluci√≥n** por las siguientes razones:

## üèóÔ∏è Arquitectura Propuesta (Refinada)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    BEDROCK KNOWLEDGE BASE                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Documento: INC-2024-001                                     ‚îÇ ‚îÇ
‚îÇ  ‚îÇ {                                                           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ   "incident_id": "INC-2024-001",                           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ   "description": "Servidor web no responde...",            ‚îÇ ‚îÇ
‚îÇ  ‚îÇ   "root_cause": "Certificado SSL expirado",                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ   "resolution": "Renovar certificado...",                  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ   "attachments_metadata": [                                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ     {                                                       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ       "file_name": "error_log.txt",                        ‚îÇ ‚îÇ
‚îÇ  ‚îÇ       "file_type": "log",                                  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ       "description": "Log de errores del servidor",        ‚îÇ ‚îÇ
‚îÇ  ‚îÇ       "s3_path": "s3://incidents-files/INC-2024-001/..."   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ     }                                                       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ   ]                                                         ‚îÇ ‚îÇ
‚îÇ  ‚îÇ }                                                           ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚îÇ B√∫squeda sem√°ntica
                              ‚îÇ Retorna: incident_id + metadata
                              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         LAMBDA FUNCTION                          ‚îÇ
‚îÇ  1. Recibe incidencias similares de Knowledge Base              ‚îÇ
‚îÇ  2. Extrae incident_ids y attachments_metadata                  ‚îÇ
‚îÇ  3. Para cada archivo en attachments_metadata:                  ‚îÇ
‚îÇ     - Construye S3 path usando incident_id                      ‚îÇ
‚îÇ     - Descarga archivo de S3                                    ‚îÇ
‚îÇ     - Procesa contenido (PDF, imagen, log, etc.)                ‚îÇ
‚îÇ  4. Construye contexto enriquecido para Claude                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         S3 BUCKETS                               ‚îÇ
‚îÇ  incidents-files/                                                ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ INC-2024-001/                                              ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ error_log.txt                                          ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ screenshot.png                                         ‚îÇ
‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ certificate_info.pdf                                   ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ INC-2024-002/                                              ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ network_trace.pcap                                     ‚îÇ
‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ config_backup.conf                                     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ ...                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## ‚úÖ Ventajas de Esta Arquitectura

### 1. **Separaci√≥n de Responsabilidades**
- **Knowledge Base**: B√∫squeda sem√°ntica de incidencias
- **S3**: Almacenamiento eficiente de archivos binarios

### 2. **Optimizaci√≥n de Costos**
- No se generan embeddings innecesarios de archivos
- Solo se procesan archivos cuando son relevantes
- Almacenamiento S3 es m√°s econ√≥mico que OpenSearch

### 3. **Flexibilidad**
- F√°cil agregar/eliminar archivos sin reindexar
- Soporta cualquier tipo de archivo
- No hay l√≠mites de tama√±o en S3

### 4. **Rendimiento**
- B√∫squeda r√°pida en Knowledge Base
- Descarga paralela de archivos desde S3
- Procesamiento bajo demanda

## üîß Mejoras Propuestas

### Mejora 1: Metadata Enriquecido en Knowledge Base

En lugar de solo el nombre del archivo, incluir **descripci√≥n sem√°ntica**:

```json
{
  "incident_id": "INC-2024-001",
  "description": "Servidor web no responde en puerto 443",
  "attachments_metadata": [
    {
      "file_name": "error_log.txt",
      "file_type": "log",
      "description": "Log de errores del servidor nginx mostrando fallos SSL",
      "summary": "M√∫ltiples errores SSL_ERROR_EXPIRED_CERT_ALERT",
      "s3_path": "s3://incidents-files/INC-2024-001/error_log.txt",
      "size_bytes": 15420,
      "created_at": "2024-09-15T10:35:00Z"
    },
    {
      "file_name": "screenshot.png",
      "file_type": "image",
      "description": "Captura de pantalla del error en navegador",
      "summary": "Error NET::ERR_CERT_DATE_INVALID en Chrome",
      "s3_path": "s3://incidents-files/INC-2024-001/screenshot.png",
      "size_bytes": 245680,
      "created_at": "2024-09-15T10:36:00Z"
    }
  ]
}
```

**Ventajas**:
- La descripci√≥n y summary son indexables sem√°nticamente
- Ayuda a Claude a entender qu√© archivos son m√°s relevantes
- Permite filtrado inteligente de archivos

### Mejora 2: Procesamiento Selectivo de Archivos

No todos los archivos son igualmente relevantes. Implementar l√≥gica de priorizaci√≥n:

```python
def prioritize_attachments(attachments_metadata, incident_context):
    """
    Prioriza qu√© archivos descargar bas√°ndose en:
    - Tipo de archivo (logs > screenshots > configs)
    - Relevancia sem√°ntica del summary
    - Tama√±o (preferir archivos peque√±os primero)
    """
    priorities = {
        'log': 10,
        'error_log': 15,
        'screenshot': 8,
        'config': 7,
        'trace': 6
    }
    
    scored_attachments = []
    for attachment in attachments_metadata:
        score = priorities.get(attachment['file_type'], 5)
        
        # Bonus por palabras clave en summary
        if 'error' in attachment.get('summary', '').lower():
            score += 5
        if 'critical' in attachment.get('summary', '').lower():
            score += 3
            
        # Penalizaci√≥n por tama√±o grande
        if attachment['size_bytes'] > 10_000_000:  # 10MB
            score -= 2
            
        scored_attachments.append((score, attachment))
    
    # Ordenar por score descendente
    scored_attachments.sort(reverse=True, key=lambda x: x[0])
    
    # Retornar top N archivos m√°s relevantes
    return [att for score, att in scored_attachments[:5]]
```

### Mejora 3: Cache de Archivos Procesados

Para archivos que se repiten en m√∫ltiples incidencias:

```python
# Usar hash del contenido como clave
file_hash = hashlib.sha256(file_content).hexdigest()
cache_key = f"processed_file:{file_hash}"

# Intentar obtener de cache (ElastiCache/Redis)
processed_content = cache.get(cache_key)

if not processed_content:
    # Procesar archivo (OCR, extracci√≥n de texto, etc.)
    processed_content = process_file(file_content)
    
    # Guardar en cache (TTL: 7 d√≠as)
    cache.set(cache_key, processed_content, ttl=604800)
```

## üéØ Soluciones Alternativas (Si la Propuesta Actual No Funciona)

### Alternativa 1: Wrapper Documents en Knowledge Base

Crear documentos "wrapper" que combinen metadata + contenido de archivos:

```json
{
  "incident_id": "INC-2024-001",
  "description": "Servidor web no responde...",
  "attachment_1_content": "<<CONTENIDO EXTRA√çDO DEL LOG>>",
  "attachment_2_content": "<<TEXTO EXTRA√çDO DE SCREENSHOT VIA OCR>>",
  "attachment_3_content": "<<CONTENIDO DEL CONFIG FILE>>"
}
```

**Ventajas**:
- Todo en un solo lugar
- B√∫squeda sem√°ntica incluye contenido de archivos

**Desventajas**:
- Documentos muy grandes
- Costos altos de embeddings
- Dif√≠cil actualizar archivos

### Alternativa 2: Knowledge Base Jer√°rquico

Dos Knowledge Bases separadas con relaci√≥n:

```
KB1: Incidencias (principal)
  ‚Üì incident_id
KB2: Archivos (secundaria)
  - Indexa contenido de archivos
  - Cada documento tiene incident_id como metadata
```

**Ventajas**:
- B√∫squeda granular
- Actualizaci√≥n independiente

**Desventajas**:
- Dos consultas necesarias
- Mayor complejidad
- Costos duplicados

### Alternativa 3: Embeddings On-Demand

No pre-indexar archivos. Generar embeddings en tiempo real:

```python
# Cuando se encuentra incidencia similar
for attachment in incident['attachments']:
    # Descargar y procesar archivo
    content = download_and_process(attachment['s3_path'])
    
    # Generar embedding on-the-fly
    embedding = generate_embedding(content)
    
    # Calcular similitud con query
    similarity = cosine_similarity(query_embedding, embedding)
    
    if similarity > threshold:
        # Incluir en contexto para Claude
        relevant_attachments.append(content)
```

**Ventajas**:
- Sin costos de indexaci√≥n
- Siempre actualizado

**Desventajas**:
- Mayor latencia
- Costos de compute en Lambda

## üìã Recomendaci√≥n Final

**Mantener tu propuesta original** con las **Mejoras 1 y 2**:

1. ‚úÖ **Metadata de incidencias en Knowledge Base** (con descripci√≥n enriquecida de archivos)
2. ‚úÖ **Archivos en S3** organizados por incident_id
3. ‚úÖ **Procesamiento selectivo** de archivos m√°s relevantes
4. ‚úÖ **Cache opcional** para archivos frecuentes

Esta arquitectura es:
- ‚úÖ **Eficiente en costos**
- ‚úÖ **Escalable**
- ‚úÖ **Flexible**
- ‚úÖ **F√°cil de mantener**

## üîÑ Flujo Optimizado

```
1. Usuario consulta: "Servidor web no responde puerto 443"
   ‚Üì
2. Knowledge Base retorna top 5 incidencias similares
   Incluye: incident_id + attachments_metadata con descriptions
   ‚Üì
3. Lambda analiza attachments_metadata:
   - Prioriza por tipo y relevancia
   - Selecciona top 3-5 archivos m√°s relevantes
   ‚Üì
4. Lambda descarga archivos de S3 en paralelo
   - Solo los archivos priorizados
   - Usa cache si est√° disponible
   ‚Üì
5. Lambda procesa archivos:
   - PDF ‚Üí Texto
   - Im√°genes ‚Üí OCR
   - Logs ‚Üí Parsing
   ‚Üì
6. Lambda construye contexto para Claude:
   - Incidencia actual
   - Top 5 incidencias similares
   - Contenido de archivos relevantes
   ‚Üì
7. Claude analiza y genera respuesta
```

## üí° Conclusi√≥n

Tu propuesta de **separar metadata (KB) y archivos (S3)** es la **soluci√≥n correcta**. 

La clave del √©xito est√° en:
1. **Enriquecer el metadata** con descripciones sem√°nticas de archivos
2. **Priorizar inteligentemente** qu√© archivos procesar
3. **Optimizar con cache** cuando sea posible

Esto te da lo mejor de ambos mundos: b√∫squeda sem√°ntica eficiente + acceso flexible a archivos.
